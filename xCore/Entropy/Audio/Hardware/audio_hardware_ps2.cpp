#include "x_target.hpp"

#if !defined(TARGET_PS2)
#error This is for a PS2 target build. Please exclude from build rules.
#endif

// 
// PLEASE DON'T LOOK! This code has got awful ugly.....
//
#include "audio_hardware_ps2_private.hpp"
#include "audio_channel_mgr.hpp"
#include "audio_hardware.hpp"
#include "audio_package.hpp"
#include "audio_inline.hpp"
#include "audio_stream_mgr.hpp"
#include "e_SimpleAllocator.hpp"
#include "ps2/iopmanager.hpp"
#include "x_log.hpp"

//------------------------------------------------------------------------------

//efine LOG_CHANNEL_ACQUIRE_NORMAL   "audio_hardware::AcquireChannel(normal)"
//#define LOG_CHANNEL_ACQUIRE_STEALING "audio_hardware::AcquireChannel(steal)"
//#define LOG_CHANNEL_ACQUIRE_FAILED   "audio_hardware::AcquireChannel(fail)"
//#define DEBUG_AUDIO

audio_hardware      g_AudioHardware;
simple_allocator    s_AramAllocator;
iop_channel_manager s_ChannelManager;

void ps2_DumpChannelInfo( void );

//------------------------------------------------------------------------------

f32 g_ProLogicIICoeff[720][2] = {
{  0.707106781f,  0.707106781f },
{  0.700909264f,  0.713250449f },
{  0.694658370f,  0.719339800f },
{  0.688354576f,  0.725374371f },
{  0.681998360f,  0.731353702f },
{  0.675590208f,  0.737277337f },
{  0.669130606f,  0.743144825f },
{  0.662620048f,  0.748955721f },
{  0.656059029f,  0.754709580f },
{  0.649448048f,  0.760405966f },
{  0.642787610f,  0.766044443f },
{  0.636078220f,  0.771624583f },
{  0.629320391f,  0.777145961f },
{  0.622514637f,  0.782608157f },
{  0.615661475f,  0.788010754f },
{  0.608761429f,  0.793353340f },
{  0.601815023f,  0.798635510f },
{  0.594822787f,  0.803856861f },
{  0.587785252f,  0.809016994f },
{  0.580702956f,  0.814115518f },
{  0.573576436f,  0.819152044f },
{  0.566406237f,  0.824126189f },
{  0.559192903f,  0.829037573f },
{  0.551936985f,  0.833885822f },
{  0.544639035f,  0.838670568f },
{  0.537299608f,  0.843391446f },
{  0.529919264f,  0.848048096f },
{  0.522498565f,  0.852640164f },
{  0.515038075f,  0.857167301f },
{  0.507538363f,  0.861629160f },
{  0.500000000f,  0.866025404f },
{  0.492423560f,  0.870355696f },
{  0.484809620f,  0.874619707f },
{  0.477158760f,  0.878817113f },
{  0.469471563f,  0.882947593f },
{  0.461748613f,  0.887010833f },
{  0.453990500f,  0.891006524f },
{  0.446197813f,  0.894934362f },
{  0.438371147f,  0.898794046f },
{  0.430511097f,  0.902585284f },
{  0.422618262f,  0.906307787f },
{  0.414693243f,  0.909961271f },
{  0.406736643f,  0.913545458f },
{  0.398749069f,  0.917060074f },
{  0.390731128f,  0.920504853f },
{  0.382683432f,  0.923879533f },
{  0.374606593f,  0.927183855f },
{  0.366501227f,  0.930417568f },
{  0.358367950f,  0.933580426f },
{  0.350207381f,  0.936672189f },
{  0.342020143f,  0.939692621f },
{  0.333806859f,  0.942641491f },
{  0.325568154f,  0.945518576f },
{  0.317304656f,  0.948323655f },
{  0.309016994f,  0.951056516f },
{  0.300705800f,  0.953716951f },
{  0.292371705f,  0.956304756f },
{  0.284015345f,  0.958819735f },
{  0.275637356f,  0.961261696f },
{  0.267238376f,  0.963630453f },
{  0.258819045f,  0.965925826f },
{  0.250380004f,  0.968147640f },
{  0.241921896f,  0.970295726f },
{  0.233445364f,  0.972369920f },
{  0.224951054f,  0.974370065f },
{  0.216439614f,  0.976296007f },
{  0.207911691f,  0.978147601f },
{  0.199367934f,  0.979924705f },
{  0.190808995f,  0.981627183f },
{  0.182235525f,  0.983254908f },
{  0.173648178f,  0.984807753f },
{  0.165047606f,  0.986285602f },
{  0.156434465f,  0.987688341f },
{  0.147809411f,  0.989015863f },
{  0.139173101f,  0.990268069f },
{  0.130526192f,  0.991444861f },
{  0.121869343f,  0.992546152f },
{  0.113203214f,  0.993571856f },
{  0.104528463f,  0.994521895f },
{  0.095845753f,  0.995396198f },
{  0.087155743f,  0.996194698f },
{  0.078459096f,  0.996917334f },
{  0.069756474f,  0.997564050f },
{  0.061048540f,  0.998134798f },
{  0.052335956f,  0.998629535f },
{  0.043619387f,  0.999048222f },
{  0.034899497f,  0.999390827f },
{  0.026176948f,  0.999657325f },
{  0.017452406f,  0.999847695f },
{  0.008726535f,  0.999961923f },
{  0.000000000f,  1.000000000f },
{ -0.008726535f,  0.999961923f },
{ -0.017452406f,  0.999847695f },
{ -0.026176948f,  0.999657325f },
{ -0.034899497f,  0.999390827f },
{ -0.043619387f,  0.999048222f },
{ -0.052335956f,  0.998629535f },
{ -0.061048540f,  0.998134798f },
{ -0.069756474f,  0.997564050f },
{ -0.078459096f,  0.996917334f },
{ -0.087155743f,  0.996194698f },
{ -0.095845753f,  0.995396198f },
{ -0.104528463f,  0.994521895f },
{ -0.113203214f,  0.993571856f },
{ -0.121869343f,  0.992546152f },
{ -0.130526192f,  0.991444861f },
{ -0.139173101f,  0.990268069f },
{ -0.147809411f,  0.989015863f },
{ -0.156434465f,  0.987688341f },
{ -0.165047606f,  0.986285602f },
{ -0.173648178f,  0.984807753f },
{ -0.182235525f,  0.983254908f },
{ -0.190808995f,  0.981627183f },
{ -0.199367934f,  0.979924705f },
{ -0.207911691f,  0.978147601f },
{ -0.216439614f,  0.976296007f },
{ -0.224951054f,  0.974370065f },
{ -0.233445364f,  0.972369920f },
{ -0.241921896f,  0.970295726f },
{ -0.250380004f,  0.968147640f },
{ -0.258819045f,  0.965925826f },
{ -0.267238376f,  0.963630453f },
{ -0.275637356f,  0.961261696f },
{ -0.284015345f,  0.958819735f },
{ -0.292371705f,  0.956304756f },
{ -0.300705800f,  0.953716951f },
{ -0.309016994f,  0.951056516f },
{ -0.317304656f,  0.948323655f },
{ -0.325568154f,  0.945518576f },
{ -0.333806859f,  0.942641491f },
{ -0.342020143f,  0.939692621f },
{ -0.350207381f,  0.936672189f },
{ -0.358367950f,  0.933580426f },
{ -0.366501227f,  0.930417568f },
{ -0.374606593f,  0.927183855f },
{ -0.382683432f,  0.923879533f },
{ -0.390731128f,  0.920504853f },
{ -0.398749069f,  0.917060074f },
{ -0.406736643f,  0.913545458f },
{ -0.414693243f,  0.909961271f },
{ -0.422618262f,  0.906307787f },
{ -0.430511097f,  0.902585284f },
{ -0.438371147f,  0.898794046f },
{ -0.446197813f,  0.894934362f },
{ -0.453990500f,  0.891006524f },
{ -0.461748613f,  0.887010833f },
{ -0.469471563f,  0.882947593f },
{ -0.477158760f,  0.878817113f },
{ -0.484809620f,  0.874619707f },
{ -0.492423560f,  0.870355696f },
{ -0.500000000f,  0.866025404f },
{ -0.507538363f,  0.861629160f },
{ -0.515038075f,  0.857167301f },
{ -0.522498565f,  0.852640164f },
{ -0.529919264f,  0.848048096f },
{ -0.537299608f,  0.843391446f },
{ -0.544639035f,  0.838670568f },
{ -0.551936985f,  0.833885822f },
{ -0.559192903f,  0.829037573f },
{ -0.566406237f,  0.824126189f },
{ -0.573576436f,  0.819152044f },
{ -0.580702956f,  0.814115518f },
{ -0.587785252f,  0.809016994f },
{ -0.594822787f,  0.803856861f },
{ -0.601815023f,  0.798635510f },
{ -0.608761429f,  0.793353340f },
{ -0.615661475f,  0.788010754f },
{ -0.622514637f,  0.782608157f },
{ -0.629320391f,  0.777145961f },
{ -0.636078220f,  0.771624583f },
{ -0.642787610f,  0.766044443f },
{ -0.649448048f,  0.760405966f },
{ -0.656059029f,  0.754709580f },
{ -0.662620048f,  0.748955721f },
{ -0.669130606f,  0.743144825f },
{ -0.675590208f,  0.737277337f },
{ -0.681998360f,  0.731353702f },
{ -0.688354576f,  0.725374371f },
{ -0.694658370f,  0.719339800f },
{ -0.700909264f,  0.713250449f },
{ -0.707106781f,  0.707106781f },
{ -0.713250449f,  0.700909264f },
{ -0.719339800f,  0.694658370f },
{ -0.725374371f,  0.688354576f },
{ -0.731353702f,  0.681998360f },
{ -0.737277337f,  0.675590208f },
{ -0.743144825f,  0.669130606f },
{ -0.748955721f,  0.662620048f },
{ -0.754709580f,  0.656059029f },
{ -0.760405966f,  0.649448048f },
{ -0.766044443f,  0.642787610f },
{ -0.771624583f,  0.636078220f },
{ -0.777145961f,  0.629320391f },
{ -0.782608157f,  0.622514637f },
{ -0.788010754f,  0.615661475f },
{ -0.793353340f,  0.608761429f },
{ -0.798635510f,  0.601815023f },
{ -0.803856861f,  0.594822787f },
{ -0.809016994f,  0.587785252f },
{ -0.814115518f,  0.580702956f },
{ -0.819152044f,  0.573576436f },
{ -0.824126189f,  0.566406237f },
{ -0.829037573f,  0.559192903f },
{ -0.833885822f,  0.551936985f },
{ -0.838670568f,  0.544639035f },
{ -0.843391446f,  0.537299608f },
{ -0.848048096f,  0.529919264f },
{ -0.852640164f,  0.522498565f },
{ -0.857167301f,  0.515038075f },
{ -0.861629160f,  0.507538363f },
{ -0.866025404f,  0.500000000f },
{ -0.870355696f,  0.492423560f },
{ -0.874619707f,  0.484809620f },
{ -0.878817113f,  0.477158760f },
{ -0.882947593f,  0.469471563f },
{ -0.887010833f,  0.461748613f },
{ -0.891006524f,  0.453990500f },
{ -0.894934362f,  0.446197813f },
{ -0.898794046f,  0.438371147f },
{ -0.902585284f,  0.430511097f },
{ -0.906307787f,  0.422618262f },
{ -0.909961271f,  0.414693243f },
{ -0.913545458f,  0.406736643f },
{ -0.917060074f,  0.398749069f },
{ -0.920504853f,  0.390731128f },
{ -0.923879533f,  0.382683432f },
{ -0.927183855f,  0.374606593f },
{ -0.930417568f,  0.366501227f },
{ -0.933580426f,  0.358367950f },
{ -0.936672189f,  0.350207381f },
{ -0.939692621f,  0.342020143f },
{ -0.942641491f,  0.333806859f },
{ -0.945518576f,  0.325568154f },
{ -0.948323655f,  0.317304656f },
{ -0.951056516f,  0.309016994f },
{ -0.953716951f,  0.300705800f },
{ -0.956304756f,  0.292371705f },
{ -0.958819735f,  0.284015345f },
{ -0.961261696f,  0.275637356f },
{ -0.963630453f,  0.267238376f },
{ -0.965925826f,  0.258819045f },
{ -0.968147640f,  0.250380004f },
{ -0.970295726f,  0.241921896f },
{ -0.972369920f,  0.233445364f },
{ -0.974370065f,  0.224951054f },
{ -0.976296007f,  0.216439614f },
{ -0.978147601f,  0.207911691f },
{ -0.979924705f,  0.199367934f },
{ -0.981627183f,  0.190808995f },
{ -0.983254908f,  0.182235525f },
{ -0.984807753f,  0.173648178f },
{ -0.986285602f,  0.165047606f },
{ -0.987688341f,  0.156434465f },
{ -0.989015863f,  0.147809411f },
{ -0.990268069f,  0.139173101f },
{ -0.991444861f,  0.130526192f },
{ -0.992546152f,  0.121869343f },
{ -0.993571856f,  0.113203214f },
{ -0.994521895f,  0.104528463f },
{ -0.995396198f,  0.095845753f },
{ -0.996194698f,  0.087155743f },
{ -0.996917334f,  0.078459096f },
{ -0.997564050f,  0.069756474f },
{ -0.998134798f,  0.061048540f },
{ -0.998629535f,  0.052335956f },
{ -0.999048222f,  0.043619387f },
{ -0.999390827f,  0.034899497f },
{ -0.999657325f,  0.026176948f },
{ -0.999847695f,  0.017452406f },
{ -0.999961923f,  0.008726535f },
{ -1.000000000f,  0.000000000f },
{ -0.999961923f, -0.008726535f },
{ -0.999847695f, -0.017452406f },
{ -0.999657325f, -0.026176948f },
{ -0.999390827f, -0.034899497f },
{ -0.999048222f, -0.043619387f },
{ -0.998629535f, -0.052335956f },
{ -0.998134798f, -0.061048540f },
{ -0.997564050f, -0.069756474f },
{ -0.996917334f, -0.078459096f },
{ -0.996194698f, -0.087155743f },
{ -0.995396198f, -0.095845753f },
{ -0.994521895f, -0.104528463f },
{ -0.993571856f, -0.113203214f },
{ -0.992546152f, -0.121869343f },
{ -0.991444861f, -0.130526192f },
{ -0.990268069f, -0.139173101f },
{ -0.989015863f, -0.147809411f },
{ -0.987688341f, -0.156434465f },
{ -0.986285602f, -0.165047606f },
{ -0.984807753f, -0.173648178f },
{ -0.983254908f, -0.182235525f },
{ -0.981627183f, -0.190808995f },
{ -0.979924705f, -0.199367934f },
{ -0.978147601f, -0.207911691f },
{ -0.976296007f, -0.216439614f },
{ -0.974370065f, -0.224951054f },
{ -0.972369920f, -0.233445364f },
{ -0.970295726f, -0.241921896f },
{ -0.968147640f, -0.250380004f },
{ -0.965925826f, -0.258819045f },
{ -0.963630453f, -0.267238376f },
{ -0.961261696f, -0.275637356f },
{ -0.958819735f, -0.284015345f },
{ -0.956304756f, -0.292371705f },
{ -0.953716951f, -0.300705800f },
{ -0.951056516f, -0.309016994f },
{ -0.948323655f, -0.317304656f },
{ -0.945518576f, -0.325568154f },
{ -0.942641491f, -0.333806859f },
{ -0.939692621f, -0.342020143f },
{ -0.936672189f, -0.350207381f },
{ -0.933580426f, -0.358367950f },
{ -0.930417568f, -0.366501227f },
{ -0.927183855f, -0.374606593f },
{ -0.923879533f, -0.382683432f },
{ -0.920504853f, -0.390731128f },
{ -0.917060074f, -0.398749069f },
{ -0.913545458f, -0.406736643f },
{ -0.909961271f, -0.414693243f },
{ -0.906307787f, -0.422618262f },
{ -0.902585284f, -0.430511097f },
{ -0.898794046f, -0.438371147f },
{ -0.894934362f, -0.446197813f },
{ -0.891006524f, -0.453990500f },
{ -0.887010833f, -0.461748613f },
{ -0.882947593f, -0.469471563f },
{ -0.878817113f, -0.477158760f },
{ -0.874619707f, -0.484809620f },
{ -0.870355696f, -0.492423560f },
{ -0.866025404f, -0.500000000f },
{ -0.861629160f, -0.507538363f },
{ -0.857167301f, -0.515038075f },
{ -0.852640164f, -0.522498565f },
{ -0.848048096f, -0.529919264f },
{ -0.843391446f, -0.537299608f },
{ -0.838670568f, -0.544639035f },
{ -0.833885822f, -0.551936985f },
{ -0.829037573f, -0.559192903f },
{ -0.824126189f, -0.566406237f },
{ -0.819152044f, -0.573576436f },
{ -0.814115518f, -0.580702956f },
{ -0.809016994f, -0.587785252f },
{ -0.803856861f, -0.594822787f },
{ -0.798635510f, -0.601815023f },
{ -0.793353340f, -0.608761429f },
{ -0.788010754f, -0.615661475f },
{ -0.782608157f, -0.622514637f },
{ -0.777145961f, -0.629320391f },
{ -0.771624583f, -0.636078220f },
{ -0.766044443f, -0.642787610f },
{ -0.760405966f, -0.649448048f },
{ -0.754709580f, -0.656059029f },
{ -0.748955721f, -0.662620048f },
{ -0.743144825f, -0.669130606f },
{ -0.737277337f, -0.675590208f },
{ -0.731353702f, -0.681998360f },
{ -0.725374371f, -0.688354576f },
{ -0.719339800f, -0.694658370f },
{ -0.713250449f, -0.700909264f },
{ -0.707106781f, -0.707106781f },
{ -0.700909264f, -0.713250449f },
{ -0.694658370f, -0.719339800f },
{ -0.688354576f, -0.725374371f },
{ -0.681998360f, -0.731353702f },
{ -0.675590208f, -0.737277337f },
{ -0.669130606f, -0.743144825f },
{ -0.662620048f, -0.748955721f },
{ -0.656059029f, -0.754709580f },
{ -0.649448048f, -0.760405966f },
{ -0.642787610f, -0.766044443f },
{ -0.636078220f, -0.771624583f },
{ -0.629320391f, -0.777145961f },
{ -0.622514637f, -0.782608157f },
{ -0.615661475f, -0.788010754f },
{ -0.608761429f, -0.793353340f },
{ -0.601815023f, -0.798635510f },
{ -0.594822787f, -0.803856861f },
{ -0.587785252f, -0.809016994f },
{ -0.580702956f, -0.814115518f },
{ -0.573576436f, -0.819152044f },
{ -0.566406237f, -0.824126189f },
{ -0.559192903f, -0.829037573f },
{ -0.551936985f, -0.833885822f },
{ -0.544639035f, -0.838670568f },
{ -0.537299608f, -0.843391446f },
{ -0.529919264f, -0.848048096f },
{ -0.522498565f, -0.852640164f },
{ -0.515038075f, -0.857167301f },
{ -0.507538363f, -0.861629160f },
{ -0.500000000f, -0.866025404f },
{ -0.492423560f, -0.870355696f },
{ -0.484809620f, -0.874619707f },
{ -0.477158760f, -0.878817113f },
{ -0.469471563f, -0.882947593f },
{ -0.461748613f, -0.887010833f },
{ -0.453990500f, -0.891006524f },
{ -0.446197813f, -0.894934362f },
{ -0.438371147f, -0.898794046f },
{ -0.430511097f, -0.902585284f },
{ -0.422618262f, -0.906307787f },
{ -0.414693243f, -0.909961271f },
{ -0.406736643f, -0.913545458f },
{ -0.398749069f, -0.917060074f },
{ -0.390731128f, -0.920504853f },
{ -0.382683432f, -0.923879533f },
{ -0.374606593f, -0.927183855f },
{ -0.366501227f, -0.930417568f },
{ -0.358367950f, -0.933580426f },
{ -0.350207381f, -0.936672189f },
{ -0.342020143f, -0.939692621f },
{ -0.333806859f, -0.942641491f },
{ -0.325568154f, -0.945518576f },
{ -0.317304656f, -0.948323655f },
{ -0.309016994f, -0.951056516f },
{ -0.300705800f, -0.953716951f },
{ -0.292371705f, -0.956304756f },
{ -0.284015345f, -0.958819735f },
{ -0.275637356f, -0.961261696f },
{ -0.267238376f, -0.963630453f },
{ -0.258819045f, -0.965925826f },
{ -0.250380004f, -0.968147640f },
{ -0.241921896f, -0.970295726f },
{ -0.233445364f, -0.972369920f },
{ -0.224951054f, -0.974370065f },
{ -0.216439614f, -0.976296007f },
{ -0.207911691f, -0.978147601f },
{ -0.199367934f, -0.979924705f },
{ -0.190808995f, -0.981627183f },
{ -0.182235525f, -0.983254908f },
{ -0.173648178f, -0.984807753f },
{ -0.165047606f, -0.986285602f },
{ -0.156434465f, -0.987688341f },
{ -0.147809411f, -0.989015863f },
{ -0.139173101f, -0.990268069f },
{ -0.130526192f, -0.991444861f },
{ -0.121869343f, -0.992546152f },
{ -0.113203214f, -0.993571856f },
{ -0.104528463f, -0.994521895f },
{ -0.095845753f, -0.995396198f },
{ -0.087155743f, -0.996194698f },
{ -0.078459096f, -0.996917334f },
{ -0.069756474f, -0.997564050f },
{ -0.061048540f, -0.998134798f },
{ -0.052335956f, -0.998629535f },
{ -0.043619387f, -0.999048222f },
{ -0.034899497f, -0.999390827f },
{ -0.026176948f, -0.999657325f },
{ -0.017452406f, -0.999847695f },
{ -0.008726535f, -0.999961923f },
{  0.000000000f, -1.000000000f },
{  0.008726535f, -0.999961923f },
{  0.017452406f, -0.999847695f },
{  0.026176948f, -0.999657325f },
{  0.034899497f, -0.999390827f },
{  0.043619387f, -0.999048222f },
{  0.052335956f, -0.998629535f },
{  0.061048540f, -0.998134798f },
{  0.069756474f, -0.997564050f },
{  0.078459096f, -0.996917334f },
{  0.087155743f, -0.996194698f },
{  0.095845753f, -0.995396198f },
{  0.104528463f, -0.994521895f },
{  0.113203214f, -0.993571856f },
{  0.121869343f, -0.992546152f },
{  0.130526192f, -0.991444861f },
{  0.139173101f, -0.990268069f },
{  0.147809411f, -0.989015863f },
{  0.156434465f, -0.987688341f },
{  0.165047606f, -0.986285602f },
{  0.173648178f, -0.984807753f },
{  0.182235525f, -0.983254908f },
{  0.190808995f, -0.981627183f },
{  0.199367934f, -0.979924705f },
{  0.207911691f, -0.978147601f },
{  0.216439614f, -0.976296007f },
{  0.224951054f, -0.974370065f },
{  0.233445364f, -0.972369920f },
{  0.241921896f, -0.970295726f },
{  0.250380004f, -0.968147640f },
{  0.258819045f, -0.965925826f },
{  0.267238376f, -0.963630453f },
{  0.275637356f, -0.961261696f },
{  0.284015345f, -0.958819735f },
{  0.292371705f, -0.956304756f },
{  0.300705800f, -0.953716951f },
{  0.309016994f, -0.951056516f },
{  0.317304656f, -0.948323655f },
{  0.325568154f, -0.945518576f },
{  0.333806859f, -0.942641491f },
{  0.342020143f, -0.939692621f },
{  0.350207381f, -0.936672189f },
{  0.358367950f, -0.933580426f },
{  0.366501227f, -0.930417568f },
{  0.374606593f, -0.927183855f },
{  0.382683432f, -0.923879533f },
{  0.390731128f, -0.920504853f },
{  0.398749069f, -0.917060074f },
{  0.406736643f, -0.913545458f },
{  0.414693243f, -0.909961271f },
{  0.422618262f, -0.906307787f },
{  0.430511097f, -0.902585284f },
{  0.438371147f, -0.898794046f },
{  0.446197813f, -0.894934362f },
{  0.453990500f, -0.891006524f },
{  0.461748613f, -0.887010833f },
{  0.469471563f, -0.882947593f },
{  0.477158760f, -0.878817113f },
{  0.484809620f, -0.874619707f },
{  0.492423560f, -0.870355696f },
{  0.500000000f, -0.866025404f },
{  0.507538363f, -0.861629160f },
{  0.515038075f, -0.857167301f },
{  0.522498565f, -0.852640164f },
{  0.529919264f, -0.848048096f },
{  0.537299608f, -0.843391446f },
{  0.544639035f, -0.838670568f },
{  0.551936985f, -0.833885822f },
{  0.559192903f, -0.829037573f },
{  0.566406237f, -0.824126189f },
{  0.573576436f, -0.819152044f },
{  0.580702956f, -0.814115518f },
{  0.587785252f, -0.809016994f },
{  0.594822787f, -0.803856861f },
{  0.601815023f, -0.798635510f },
{  0.608761429f, -0.793353340f },
{  0.615661475f, -0.788010754f },
{  0.622514637f, -0.782608157f },
{  0.629320391f, -0.777145961f },
{  0.636078220f, -0.771624583f },
{  0.642787610f, -0.766044443f },
{  0.649448048f, -0.760405966f },
{  0.656059029f, -0.754709580f },
{  0.662620048f, -0.748955721f },
{  0.669130606f, -0.743144825f },
{  0.675590208f, -0.737277337f },
{  0.681998360f, -0.731353702f },
{  0.688354576f, -0.725374371f },
{  0.694658370f, -0.719339800f },
{  0.700909264f, -0.713250449f },
{  0.707106781f, -0.707106781f },
{  0.713250449f, -0.700909264f },
{  0.719339800f, -0.694658370f },
{  0.725374371f, -0.688354576f },
{  0.731353702f, -0.681998360f },
{  0.737277337f, -0.675590208f },
{  0.743144825f, -0.669130606f },
{  0.748955721f, -0.662620048f },
{  0.754709580f, -0.656059029f },
{  0.760405966f, -0.649448048f },
{  0.766044443f, -0.642787610f },
{  0.771624583f, -0.636078220f },
{  0.777145961f, -0.629320391f },
{  0.782608157f, -0.622514637f },
{  0.788010754f, -0.615661475f },
{  0.793353340f, -0.608761429f },
{  0.798635510f, -0.601815023f },
{  0.803856861f, -0.594822787f },
{  0.809016994f, -0.587785252f },
{  0.814115518f, -0.580702956f },
{  0.819152044f, -0.573576436f },
{  0.824126189f, -0.566406237f },
{  0.829037573f, -0.559192903f },
{  0.833885822f, -0.551936985f },
{  0.838670568f, -0.544639035f },
{  0.843391446f, -0.537299608f },
{  0.848048096f, -0.529919264f },
{  0.852640164f, -0.522498565f },
{  0.857167301f, -0.515038075f },
{  0.861629160f, -0.507538363f },
{  0.866025404f, -0.500000000f },
{  0.870355696f, -0.492423560f },
{  0.874619707f, -0.484809620f },
{  0.878817113f, -0.477158760f },
{  0.882947593f, -0.469471563f },
{  0.887010833f, -0.461748613f },
{  0.891006524f, -0.453990500f },
{  0.894934362f, -0.446197813f },
{  0.898794046f, -0.438371147f },
{  0.902585284f, -0.430511097f },
{  0.906307787f, -0.422618262f },
{  0.909961271f, -0.414693243f },
{  0.913545458f, -0.406736643f },
{  0.917060074f, -0.398749069f },
{  0.920504853f, -0.390731128f },
{  0.923879533f, -0.382683432f },
{  0.927183855f, -0.374606593f },
{  0.930417568f, -0.366501227f },
{  0.933580426f, -0.358367950f },
{  0.936672189f, -0.350207381f },
{  0.939692621f, -0.342020143f },
{  0.942641491f, -0.333806859f },
{  0.945518576f, -0.325568154f },
{  0.948323655f, -0.317304656f },
{  0.951056516f, -0.309016994f },
{  0.953716951f, -0.300705800f },
{  0.956304756f, -0.292371705f },
{  0.958819735f, -0.284015345f },
{  0.961261696f, -0.275637356f },
{  0.963630453f, -0.267238376f },
{  0.965925826f, -0.258819045f },
{  0.968147640f, -0.250380004f },
{  0.970295726f, -0.241921896f },
{  0.972369920f, -0.233445364f },
{  0.974370065f, -0.224951054f },
{  0.976296007f, -0.216439614f },
{  0.978147601f, -0.207911691f },
{  0.979924705f, -0.199367934f },
{  0.981627183f, -0.190808995f },
{  0.983254908f, -0.182235525f },
{  0.984807753f, -0.173648178f },
{  0.986285602f, -0.165047606f },
{  0.987688341f, -0.156434465f },
{  0.989015863f, -0.147809411f },
{  0.990268069f, -0.139173101f },
{  0.991444861f, -0.130526192f },
{  0.992546152f, -0.121869343f },
{  0.993571856f, -0.113203214f },
{  0.994521895f, -0.104528463f },
{  0.995396198f, -0.095845753f },
{  0.996194698f, -0.087155743f },
{  0.996917334f, -0.078459096f },
{  0.997564050f, -0.069756474f },
{  0.998134798f, -0.061048540f },
{  0.998629535f, -0.052335956f },
{  0.999048222f, -0.043619387f },
{  0.999390827f, -0.034899497f },
{  0.999657325f, -0.026176948f },
{  0.999847695f, -0.017452406f },
{  0.999961923f, -0.008726535f },
{  1.000000000f,  0.000000000f },
{  0.999961923f,  0.008726535f },
{  0.999847695f,  0.017452406f },
{  0.999657325f,  0.026176948f },
{  0.999390827f,  0.034899497f },
{  0.999048222f,  0.043619387f },
{  0.998629535f,  0.052335956f },
{  0.998134798f,  0.061048540f },
{  0.997564050f,  0.069756474f },
{  0.996917334f,  0.078459096f },
{  0.996194698f,  0.087155743f },
{  0.995396198f,  0.095845753f },
{  0.994521895f,  0.104528463f },
{  0.993571856f,  0.113203214f },
{  0.992546152f,  0.121869343f },
{  0.991444861f,  0.130526192f },
{  0.990268069f,  0.139173101f },
{  0.989015863f,  0.147809411f },
{  0.987688341f,  0.156434465f },
{  0.986285602f,  0.165047606f },
{  0.984807753f,  0.173648178f },
{  0.983254908f,  0.182235525f },
{  0.981627183f,  0.190808995f },
{  0.979924705f,  0.199367934f },
{  0.978147601f,  0.207911691f },
{  0.976296007f,  0.216439614f },
{  0.974370065f,  0.224951054f },
{  0.972369920f,  0.233445364f },
{  0.970295726f,  0.241921896f },
{  0.968147640f,  0.250380004f },
{  0.965925826f,  0.258819045f },
{  0.963630453f,  0.267238376f },
{  0.961261696f,  0.275637356f },
{  0.958819735f,  0.284015345f },
{  0.956304756f,  0.292371705f },
{  0.953716951f,  0.300705800f },
{  0.951056516f,  0.309016994f },
{  0.948323655f,  0.317304656f },
{  0.945518576f,  0.325568154f },
{  0.942641491f,  0.333806859f },
{  0.939692621f,  0.342020143f },
{  0.936672189f,  0.350207381f },
{  0.933580426f,  0.358367950f },
{  0.930417568f,  0.366501227f },
{  0.927183855f,  0.374606593f },
{  0.923879533f,  0.382683432f },
{  0.920504853f,  0.390731128f },
{  0.917060074f,  0.398749069f },
{  0.913545458f,  0.406736643f },
{  0.909961271f,  0.414693243f },
{  0.906307787f,  0.422618262f },
{  0.902585284f,  0.430511097f },
{  0.898794046f,  0.438371147f },
{  0.894934362f,  0.446197813f },
{  0.891006524f,  0.453990500f },
{  0.887010833f,  0.461748613f },
{  0.882947593f,  0.469471563f },
{  0.878817113f,  0.477158760f },
{  0.874619707f,  0.484809620f },
{  0.870355696f,  0.492423560f },
{  0.866025404f,  0.500000000f },
{  0.861629160f,  0.507538363f },
{  0.857167301f,  0.515038075f },
{  0.852640164f,  0.522498565f },
{  0.848048096f,  0.529919264f },
{  0.843391446f,  0.537299608f },
{  0.838670568f,  0.544639035f },
{  0.833885822f,  0.551936985f },
{  0.829037573f,  0.559192903f },
{  0.824126189f,  0.566406237f },
{  0.819152044f,  0.573576436f },
{  0.814115518f,  0.580702956f },
{  0.809016994f,  0.587785252f },
{  0.803856861f,  0.594822787f },
{  0.798635510f,  0.601815023f },
{  0.793353340f,  0.608761429f },
{  0.788010754f,  0.615661475f },
{  0.782608157f,  0.622514637f },
{  0.777145961f,  0.629320391f },
{  0.771624583f,  0.636078220f },
{  0.766044443f,  0.642787610f },
{  0.760405966f,  0.649448048f },
{  0.754709580f,  0.656059029f },
{  0.748955721f,  0.662620048f },
{  0.743144825f,  0.669130606f },
{  0.737277337f,  0.675590208f },
{  0.731353702f,  0.681998360f },
{  0.725374371f,  0.688354576f },
{  0.719339800f,  0.694658370f },
{  0.713250449f,  0.700909264f },
};

//==============================================================================
// Hardware specific functions.
//==============================================================================

#include "x_files.hpp"
#include "audio_hardware.hpp"
#include "audio_channel_mgr.hpp"
#include "audio_stream_mgr.hpp"

#include "sifrpc.h"
#include "eekernel.h"

sceSifClientData s_ChanClientData               PS2_ALIGNMENT(64);
iop_channel_buffer s_ChanBuffer PS2_ALIGNMENT(64);

#define SAMPLES_TO_ADPCM_BYTES(x)  ((x)*16/28)
#define ADPCM_BYTES_TO_SAMPLES(x)  ((x)*28/16)

const char* GetStatusName( s32 Status );
//------------------------------------------------------------------------------
static channel      s_Channels[ MAX_CHANNELS ];    // Channel buffer
static xbool        s_Initialized = FALSE;

//------------------------------------------------------------------------------
static void ps2_UpdateStreamADPCM( channel* pChannel)
{
    xbool bTransition      = FALSE;
    u32   CurrentPosition  = pChannel->CurrBufferPosition;
    u32   PreviousPosition = pChannel->StreamData.PreviousPosition; 

    // Which buffer are we in?
    if( PreviousPosition <= pChannel->MidPoint )
    {
        // Did a buffer transition occur?
        bTransition = (CurrentPosition > pChannel->MidPoint);
    }
    else
    {
        // Did a buffer transition occur?
        bTransition = (CurrentPosition <= pChannel->MidPoint);
    }

    // Transition occur?
    if( bTransition )
    {
        // We have played an entire buffers worth of samples!
        pChannel->StreamData.nSamplesPlayed += ADPCM_BYTES_TO_SAMPLES( STREAM_BUFFER_SIZE );

        // Stream done?
        if( pChannel->StreamData.pStream->StreamDone )
        {
        }
        // Need to read from the stream?
        else if( pChannel->StreamData.StreamControl )
        {
            // Fill the read buffer.
            g_AudioStreamMgr.ReadStream( pChannel->StreamData.pStream );
        }
    }

    // Turn looping off.
    hot_sample* pSample;
    s32         LengthInBytes;
    s32         RemainingLength;
    u32         EndAddressBytes;

    // Each adpcm sample block is 16 bytes long. It contains 28 samples.
    pSample         = pChannel->Sample.pHotSample;
    LengthInBytes   = SAMPLES_TO_ADPCM_BYTES(pSample->nSamples - 1);
    RemainingLength = ( LengthInBytes % (STREAM_BUFFER_SIZE * 2));
    EndAddressBytes = pSample->AudioRam + RemainingLength;

    // Less than one buffers worth of samples left?
    if( ((pSample->nSamples-pChannel->StreamData.nSamplesPlayed) < ADPCM_BYTES_TO_SAMPLES(STREAM_BUFFER_SIZE) ) && pChannel->StreamData.bStopLoop )
    {
        // Is the play position PAST the end of the actual sample?
        if( EndAddressBytes < pChannel->CurrBufferPosition )
        {
            // Release the channel. NOTE: Some amount of audio 
            // corruption MIGHT occur when this happens.
            g_AudioHardware.ReleaseChannel( pChannel );
        }
        else
        {
            s_ChannelManager.SetLoopEnd(pChannel->Hardware.ChannelId,NULL/*(byte*)pSample->AudioRam+RemainingLength*/);
            s_ChannelManager.SetLoopStart(pChannel->Hardware.ChannelId,NULL);
            s_ChannelManager.SetLength(pChannel->Hardware.ChannelId,RemainingLength);
        }

        // Clear flag.
        pChannel->StreamData.bStopLoop = FALSE;
    }

    pChannel->StreamData.PreviousPosition = pChannel->CurrBufferPosition;
}

//------------------------------------------------------------------------------
void audio_hardware::UpdateStream( channel* pChannel )
{
    // Cold, active, running channel?
    if( (pChannel != NULL) && 
        (pChannel->Type == COLD_SAMPLE) && 
        (pChannel->Hardware.ChannelId != INVALID_CHANNEL) && 
        (s_ChannelManager.GetState(pChannel->Hardware.ChannelId)!=CHANSTAT_IDLE) &&
        (pChannel->StreamData.pStream)  // rmbtest 
      )
    { 
        // What kind of compression?
        switch( pChannel->Sample.pHotSample->CompressionType )
        {
            // ADPCM?
            case ADPCM:
                ps2_UpdateStreamADPCM( pChannel );
                break;

            default:
                ASSERT( 0 );
                break;
        }
    }
}

//------------------------------------------------------------------------------
audio_hardware::audio_hardware( void )
{
    m_FirstChannel   = s_Channels;
    m_LastChannel    = s_Channels + (MAX_CHANNELS - 1);
    m_InterruptLevel = 0;
    m_InterruptState = FALSE;

}

//------------------------------------------------------------------------------
audio_hardware::~audio_hardware( void )
{

}

//------------------------------------------------------------------------------
void audio_hardware::Init( s32 MemSize )
{

    s32 memsize;
    ASSERT( m_InterruptLevel == 0 );
    s_ChannelManager.Init();
    memsize = s_ChannelManager.Init(MemSize);

    s_AramAllocator.Init((void*)0,memsize);

    m_PitchFactor  = 1.0f;
    m_VolumeFactor = 1.0f;
}

//------------------------------------------------------------------------------
void audio_hardware::Kill( void )
{
    ASSERT( m_InterruptLevel == 0 );
    s_AramAllocator.Kill();
    s_ChannelManager.Kill();
}

//------------------------------------------------------------------------------
void audio_hardware::ResizeMemory( s32 MemSize )
{
    s32 NewSize;

    Lock();
    s_AramAllocator.Kill();
    NewSize = s_ChannelManager.ResizeMemory( MemSize );
    s_AramAllocator.Init( (void*)0, NewSize );
    Unlock();
}

static xbool DUMP_CHANNELS = 0;

//------------------------------------------------------------------------------
void audio_hardware::Update( void )
{
    if( DUMP_CHANNELS )
    {
        DUMP_CHANNELS = 0;
        ps2_DumpChannelInfo();
    }
    s_ChannelManager.Update();
}

//------------------------------------------------------------------------------

xbool audio_hardware::AcquireChannel( channel* pChannel )
{
    s32 i;
    s32 iLowestPriority = -1;
    s32 LowestPriority  = 0x7fffffff;

    // Walk the entire list looking for A free channel...
    for( i=0; i<MAX_CHANNELS; i++ )
    {
        // Is it idle?
        if( s_ChannelManager.GetState(i)==CHANSTAT_IDLE )
        {
            // Woot! Found an UNUSED channel, acquire that bad boy!
            pChannel->Hardware.RelativeBufferPosition = 0;
            pChannel->Hardware.ChannelId = i;
            s_ChannelManager.SetState(i,CHANSTAT_STOPPED);
            s_ChannelManager.SetOwner(i,pChannel);
            s_ChannelManager.SetPriority(i,pChannel->Priority);

#if defined(LOG_CHANNEL_ACQUIRE_NORMAL) && defined(X_LOGGING)
            {
                voice* pVoice     = NULL;
                const char* pName = "Unknown";
                if( pChannel->pElement )
                    pVoice = pChannel->pElement->pVoice;
                if( pVoice && pVoice->pDescriptorName )
                    pName = pVoice->pDescriptorName;
                LOG_MESSAGE( LOG_CHANNEL_ACQUIRE_NORMAL, 
                             "ACQUIRE channel: %02d, priority: %03d, voice: %08x [%s]", 
                             i, 
                             pChannel->Priority,
                             pVoice,
                             pName );
            }
#endif // defined(LOG_CHANNEL_ACQUIRE_NORMAL) && defined(X_LOGGING)

            return TRUE;
        }

        // Keep track of lowest PRIORITY for channel stealing.
        if( (s_ChannelManager.GetPriority( i ) < LowestPriority) && (s_ChannelManager.GetState(i) != CHANSTAT_STEALING) )
        {
            LowestPriority  = s_ChannelManager.GetPriority( i );
            iLowestPriority = i; 
        }
    }

    // Now free a channel (need to drop lowest priority one).
    if( (iLowestPriority != -1) && (LowestPriority < pChannel->Priority) )
    {
        // Nuke the channel.
        channel* pChannelToTake = (channel*)s_ChannelManager.GetOwner( iLowestPriority );
        pChannelToTake->Hardware.ChannelId = INVALID_CHANNEL;

#if defined(LOG_CHANNEL_ACQUIRE_STEALING) && defined(X_LOGGING)
        {
            // Log the fact we are stealing a channel.
            voice*      pVoice = NULL;
            const char* pName  = "Unknown";
            if( pChannelToTake->pElement )
                pVoice = pChannelToTake->pElement->pVoice;
            if( pVoice && pVoice->pDescriptorName )
                pName = pVoice->pDescriptorName;
            LOG_WARNING( LOG_CHANNEL_ACQUIRE_STEALING, 
                         "*STEAL* channel: %02d, priority: %03d, voice: %08x [%s]",
                         iLowestPriority,
                         pChannelToTake->Priority,
                         pVoice,
                         pName );

            // Now log the acquisition.
            pVoice = NULL;
            pName  = "Unknown";
            if( pChannel->pElement )
                pVoice = pChannel->pElement->pVoice;
            if( pVoice && pVoice->pDescriptorName )
                pName = pVoice->pDescriptorName;
            LOG_MESSAGE( LOG_CHANNEL_ACQUIRE_STEALING, 
                         "ACQUIRE channel: %02d, priority: %03d, voice: %08x [%s]",
                         iLowestPriority,
                         pChannel->Priority,
                         pVoice,
                         pName );
        }
#endif // defined(LOG_CHANNEL_ACQUIRE_STEALING) && defined(X_LOGGING)

        // Now assigne the channel.
        pChannel->Hardware.RelativeBufferPosition = 0;
        pChannel->Hardware.ChannelId = iLowestPriority;
        s_ChannelManager.SetState(iLowestPriority,CHANSTAT_STEALING);
        s_ChannelManager.SetOwner(iLowestPriority,pChannel);
        s_ChannelManager.SetPriority(iLowestPriority,pChannel->Priority);
        return TRUE;
    }

#if defined(LOG_CHANNEL_ACQUIRE_FAILED) && defined(X_LOGGING)
    LOG_WARNING( "audio_hardware::AcquireChannel",
               "FAILED TO ACQUIRE!!! Required Priority:%d, Lowest Priority Found:%d", 
               pChannel->Priority, 
               LowestPriority );
#endif // defined(LOG_CHANNEL_ACQUIRE_FAILED) && defined(X_LOGGING) 

    return FALSE;
}

//------------------------------------------------------------------------------

void audio_hardware::ReleaseChannel      ( channel*      pChannel )
{
    // Look for segue.
    if( pChannel->pElement && pChannel->pElement->pVoice )
    {
        voice* pVoice = pChannel->pElement->pVoice;
        voice* pNext  = pVoice->pSegueVoiceNext;
        voice* pPrev  = pVoice->pSegueVoicePrev;

        // Take it out of list
        if( pPrev )
        {
            pPrev->pSegueVoiceNext = NULL;
        }

        if( pNext && (pNext->StartQ == 0) )
        {
            // Mark the queued voice to start.
            pNext->StartQ          = 1;
            pNext->pSegueVoicePrev = NULL;
        }
    }

    if ( IsChannelActive(pChannel) )
    {
        StopChannel(pChannel);
    }

    // Does this channel have a stream?
    if( pChannel->StreamData.pStream && pChannel->StreamData.StreamControl )
    {
        // If so, nuke the stream
        g_AudioStreamMgr.ReleaseStream( pChannel->StreamData.pStream );
        pChannel->StreamData.pStream = NULL;
    }
    pChannel->Hardware.ChannelId = INVALID_CHANNEL;
}

//------------------------------------------------------------------------------

void audio_hardware::ClearChannel        ( channel*      pChannel )
{
    (void)pChannel;
}

//------------------------------------------------------------------------------

void audio_hardware::DuplicatePriority   ( channel*      pDest, channel* pSrc )
{
    (void)pDest;
    (void)pSrc;
}

//------------------------------------------------------------------------------

xbool audio_hardware::IsChannelActive     ( channel*      pChannel )
{
    if (pChannel->Hardware.ChannelId == INVALID_CHANNEL)
        return FALSE;
    return (s_ChannelManager.GetState(pChannel->Hardware.ChannelId) != CHANSTAT_IDLE);
}

//------------------------------------------------------------------------------

void audio_hardware::StartChannel        ( channel*      pChannel )
{
    s_ChannelManager.SetState(pChannel->Hardware.ChannelId,CHANSTAT_WARMING);
}

//------------------------------------------------------------------------------

void audio_hardware::StopChannel         ( channel*      pChannel )
{
    s_ChannelManager.SetState(pChannel->Hardware.ChannelId,CHANSTAT_COOLING);
}

//------------------------------------------------------------------------------

void audio_hardware::PauseChannel         ( channel*      pChannel )
{
    s_ChannelManager.SetPitch(pChannel->Hardware.ChannelId,0);
}

//------------------------------------------------------------------------------

void audio_hardware::ResumeChannel         ( channel*      pChannel )
{
    s_ChannelManager.SetPitch(pChannel->Hardware.ChannelId,pChannel->Pitch);
}

//------------------------------------------------------------------------------

void audio_hardware::InitChannel         ( channel*      pChannel )
{
    s32 id;

    id = pChannel->Hardware.ChannelId;
    s_ChannelManager.SetVolume      (id,pChannel->Volume*pChannel->Pan3d.GetX(), pChannel->Volume*pChannel->Pan3d.GetY());
    s_ChannelManager.SetPitch       (id,1.0f);//(Id,pChannel->Pitch);
    s_ChannelManager.SetSample      (id,(byte*)pChannel->Sample.pHotSample->AudioRam);
    s_ChannelManager.SetSampleRate  (id,pChannel->Sample.pHotSample->SampleRate);
    s_ChannelManager.SetPriority    (id,pChannel->Priority);
    s_ChannelManager.SetLength      (id,pChannel->Sample.pHotSample->WaveformLength);
    s_ChannelManager.SetReverb      (id, 0.0f);

    if (pChannel->Sample.pHotSample->LoopEnd)
    {
        s_ChannelManager.SetLoopStart   (id, (byte*)pChannel->Sample.pHotSample->AudioRam + SAMPLES_TO_ADPCM_BYTES(pChannel->Sample.pHotSample->LoopStart)+16);
        s_ChannelManager.SetLoopEnd     (id, (byte*)pChannel->Sample.pHotSample->AudioRam + SAMPLES_TO_ADPCM_BYTES(pChannel->Sample.pHotSample->LoopEnd)+16);
    }
    else
    {
        s_ChannelManager.SetLoopStart   (id, NULL);
        s_ChannelManager.SetLoopEnd     (id, NULL);
    }

    // Init.
    pChannel->nSamplesAdjust  =
    pChannel->nSamplesBase    =
    pChannel->PlayPosition    =
    pChannel->ReleasePosition = 0;
}

//------------------------------------------------------------------------------

void audio_hardware::InitChannelStreamed ( channel*      pChannel )
{
    // NOTE: SPECIAL CASE JUST FOR STREAMING, PLEASE MODIFY WHEN STREAMING
    // IS ENABLED FOR PS2.

    hot_sample*         pSample          = pChannel->Sample.pHotSample;
    s32                 id               = pChannel->Hardware.ChannelId;
    s32                 Length           = pSample->LoopEnd - pSample->LoopStart;

    ASSERT( pSample->LoopEnd );

    // In this case, pSample->LoopStart and pSample->LoopEnd contain the OFFSETS within pSample->AudioRam that
    // contain the beginning and end of the stream buffer for this channel.
    s_ChannelManager.SetVolume      (id,pChannel->Volume*pChannel->Pan3d.GetX(), pChannel->Volume*pChannel->Pan3d.GetY());
    s_ChannelManager.SetPitch       (id,1.0f);//(Id,pChannel->Pitch);
    s_ChannelManager.SetPriority    (id,pChannel->Priority);
    s_ChannelManager.SetSampleRate  (id,pChannel->Sample.pHotSample->SampleRate);
    s_ChannelManager.SetSample      (id,(byte*)pSample->AudioRam);
    s_ChannelManager.SetLength      (id,Length);

    s_ChannelManager.SetLoopStart   (id,(byte*)pSample->AudioRam);
    s_ChannelManager.SetLoopEnd     (id,(byte*)pSample->AudioRam + Length);


    // Set the current position
    pChannel->PrevBufferPosition =
    pChannel->CurrBufferPosition = pSample->AudioRam;
    pChannel->MidPoint           = pSample->AudioRam+(Length/2);

    // Init.
    pChannel->nSamplesAdjust  =
    pChannel->nSamplesBase    =
    pChannel->PlayPosition    =
    pChannel->ReleasePosition = 0;

    // Nuke the number of samples played.
    pChannel->StreamData.nSamplesPlayed = 0;

    // Copy it to the stream previous.
    pChannel->StreamData.PreviousPosition = pChannel->CurrBufferPosition;
}

//------------------------------------------------------------------------------

void audio_hardware::Lock               ( void )
{
    m_LockMutex.Acquire();

    ASSERT(m_InterruptLevel >= 0);
    m_InterruptLevel++;
}

//------------------------------------------------------------------------------

void audio_hardware::Unlock             ( void )
{
    ASSERT(m_InterruptLevel>0);
    m_InterruptLevel--;
    m_LockMutex.Release();
}

//------------------------------------------------------------------------------
            
s32 audio_hardware::NumChannels         ( void )
{
    return MAX_CHANNELS;
}

//------------------------------------------------------------------------------

channel* audio_hardware::GetChannelBuffer    ( void )
{
    return s_Channels;
}

//------------------------------------------------------------------------------
void* audio_hardware::AllocAudioRam( s32 nBytes )
{
    nBytes = (nBytes + 31) & ~31;

    // On the PS2, we can actually obtain an allocated address of 0, so we make sure we
    // check the amount free first so we can verify allocations will have succeeded.
    if (s_AramAllocator.GetFree() < nBytes)
    {
        x_DebugMsg("AllocARAM: Allocation of size %d failed.\n",nBytes);
        s_AramAllocator.DumpList();
        return 0;
    }

    return s_AramAllocator.Alloc( nBytes );
}

//------------------------------------------------------------------------------

void audio_hardware::FreeAudioRam( void* Address )
{
    s_AramAllocator.Free( Address );
}

//------------------------------------------------------------------------------

s32 audio_hardware::GetAudioRamFree     ( void )
{
    return s_AramAllocator.GetFree();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
s32 RpcType;
s32 RpcReturn;
xmutex s_RpcLock;

static s32 CallRpc( s32 Function, s32 SendLength, s32 ReturnLength )
{
    s32 Result;

    ASSERT( s_RpcLock.IsLocked() );
    FlushCache(0);
    ASSERT( RpcType == 0 );
    RpcType = Function;

    SendLength   = (SendLength + 15)&~15;
    ReturnLength = (ReturnLength+15)&~15;
    if( SendLength == 0 )       SendLength = 16;
    if( ReturnLength == 0 )     ReturnLength = 16;

    sceSifCallRpc (&s_ChanClientData,  
                    Function,0,
                    &s_ChanBuffer,SendLength,
                    &s_ChanBuffer,ReturnLength,
                    NULL,NULL);
    RpcReturn = s_ChanBuffer.Longs[0];
    RpcType = 0;
    Result = s_ChanBuffer.Longs[0];
    return Result;
}

//-----------------------------------------------------------------------------
// This init call is done during initial startup of the iop manager. All it is
// supposed to do is initialize the rpc path. This will kick off a series of
// operations on the iop side
void iop_channel_manager::Init(void)
{
    s32 result;
    s32 i;
    xtimer t;

    SetMasterVolume( 1.0f );
    SetPCMVolume( 0.25f );
    SetReverbType( REVERB_HALL, 0.0f ); //0.50f );

    x_memset( m_Channels, 0, sizeof(m_Channels) );
    ASSERT( !s_Initialized );
    t.Start();
    while( TRUE ) 
    {
        result = sceSifBindRpc (&s_ChanClientData, CHANNEL_RPC_DEV, 0);
        ASSERTS(result>=0,"error: sceSifBindRpc failed");

        if( s_ChanClientData.serve != 0 ) break;

        if( t.ReadSec() > 2.0f )
        {
            ASSERTS(FALSE,"iop_channel_manager::Init() - RPC call took too long, check init order\n");
        }
    }
    s_Initialized = TRUE;

    for( i=0; i<MAX_DEFAULT_MESSAGES; i++ )
    {
        m_qPushAvail.Send(m_PushRequests+i,MQ_BLOCK);
    }
}

//-----------------------------------------------------------------------------
// This init call actually sets up the channel manager. It is up to the application
// to specify how much ee side memory is to be donated to the iop audio layer.
// It returns the amount of memory actually assigned by the audio layer on the iop (which
// includes SPU, IOP and EE memory
s32 iop_channel_manager::Init(s32 Length)
{
    s32 i;
    s32 memsize;
    s32 RemoteMemSize;
    s32 LocalMemSize;
    s32 VersionId;

    MEMORY_OWNER( "iop_channel_manager::Init()" );

    // Do the RPC call to initialize the channel manager with the size
    // of the amount of memory to use.

    ASSERT(Length);

    s_RpcLock.Acquire();
    VersionId = CallRpc( CHANCMD_GET_VERSION, 0, 0 );
    ASSERTS(VersionId == AUDIO_MODULE_VERSION,xfs("IOP Audio module version mismatch. Got %04x, expected %04x",VersionId, AUDIO_MODULE_VERSION));
    // Set up # bytes requested.
    RemoteMemSize = CallRpc( CHANCMD_PRE_INIT,0,0 );
    // RemoteMemSize now
    // Length is the total audio memory. As of the moment, the IOP contains 2.25M of audio
    // memory.
    //
    // Note: If we're allocating just a small audio memory footprint, to keep a lot of space available on the iop,
    // then we can be in a situation where, say, only 1MB is requested and 1.6M is given as that is the minimum
    // amount that can be allocated on IOP (it's the size of the SPU portion of audio memory).
    LocalMemSize = Length - RemoteMemSize;
    if( LocalMemSize <= 0 )
    {
        LocalMemSize = 0;
    }
    m_LocalData = x_malloc(LocalMemSize);
    ASSERT(m_LocalData);
    x_memset(m_LocalData,0x0,LocalMemSize);
    s_ChanBuffer.Longs[0]=(u32)m_LocalData;
    s_ChanBuffer.Longs[1]=LocalMemSize;
    memsize = CallRpc(CHANCMD_INIT,0,0);
    ASSERT(memsize > 0);
    for( i=0; i<MAX_CHANNELS; i++ )
    {
        SetState(i,CHANSTAT_IDLE);
    }
    s_RpcLock.Release();

    ASSERTS(memsize >= Length,"IOP did not return correct amount of audio memory available");
    x_DebugMsg("iop_channel_manager::Init() - Remote audio memory:%d, Local audio memory:%d, total audio memory:%d\n",RemoteMemSize,LocalMemSize,memsize);
                            
    return memsize;
}

//-----------------------------------------------------------------------------
// Make sure the channel manager shuts down gracefully.
void iop_channel_manager::Kill(void)
{
    s32 i;

    ASSERT(m_qPushPending.IsEmpty());

    for( i=0; i<MAX_DEFAULT_MESSAGES; i++ )
    {
        VERIFY(m_qPushAvail.Recv(MQ_NOBLOCK));
    }
    if( s_RpcLock.IsLocked() == FALSE )
    {
        s_RpcLock.Acquire();
    }
    CallRpc( CHANCMD_KILL,0,0 );
    s_RpcLock.Release();
    x_free( m_LocalData );
    m_LocalData = NULL;
    ASSERT( s_Initialized );
    s_Initialized = FALSE;
}

//------------------------------------------------------------------------------
// GCN Code.
//------------------------------------------------------------------------------

void audio_hardware::SetReverbWetDryMix( f32 Mix )
{
    (void)Mix;
    //s_ChannelManager.SetReverbType( REVERB_HALL, Mix );
}

u32 audio_hardware::GetSamplesPlayed( channel* pChannel )
{
    // What kind of compression?
    switch( pChannel->Sample.pHotSample->CompressionType )
    {
        // ADPCM?
        case ADPCM:
        {
            pChannel->nSamplesAdjust = ADPCM_BYTES_TO_SAMPLES( pChannel->Hardware.RelativeBufferPosition );
            break;
        }

        default:
            ASSERT( 0 );
            break;
    }

    // Tell the world.
    return pChannel->nSamplesBase + pChannel->nSamplesAdjust;
}

//------------------------------------------------------------------------------

static xbool UpdatePosition( channel* pChannel )
{
    // Only need to do special stuff for cold samples
    if( pChannel->Type == COLD_SAMPLE )
    {
        // Played an entire buffers worth of samples?
        if( (pChannel->PrevBufferPosition >= pChannel->MidPoint) &&  
            (pChannel->CurrBufferPosition  <  pChannel->MidPoint) )
        {
            // What kind of compression?
            switch( pChannel->Sample.pHotSample->CompressionType )
            {
                // ADPCM?
                case ADPCM:
                    // This is one messed up equation...
                    pChannel->nSamplesBase += ADPCM_BYTES_TO_SAMPLES(STREAM_BUFFER_SIZE*2);
                    break;

                default:
                    ASSERT( 0 );
                    break;
            }
        }
    
        // Update previous.
        pChannel->PrevBufferPosition = pChannel->CurrBufferPosition;
    }

    if( (pChannel->nSamplesBase + ADPCM_BYTES_TO_SAMPLES( pChannel->Hardware.RelativeBufferPosition )) >= (u32)pChannel->Sample.pHotSample->nSamples-1 )
        return FALSE;

    // Release position specified?
    if( pChannel->ReleasePosition )
    {
        // Calculate number of samples played.
        pChannel->PlayPosition = g_AudioHardware.GetSamplesPlayed( pChannel );

        // Past the release position?
        if( pChannel->PlayPosition >= pChannel->ReleasePosition )
        {
            // All bad...
            return FALSE;
        }
    }

    // All good!
    return TRUE;
}

//-----------------------------------------------------------------------------
s32 iop_channel_manager::ResizeMemory( s32 NewSize )
{
    s32 RemoteMemSize;
    s32 LocalMemSize;
    s32 TotalMemSize;

    MEMORY_OWNER( "iop_channel_manager::ResizeMemory()" );

    // This will return the base amount of memory available to audio on the IOP. This
    // will include SPU and IOP memory.
    s_RpcLock.Acquire();
    RemoteMemSize = CallRpc( CHANCMD_RELEASEMEMORY,0,0 );

    LocalMemSize = NewSize - RemoteMemSize;
    if( LocalMemSize <= 0 )
    {
        LocalMemSize = 0;
    }
    x_free(m_LocalData);

    m_LocalData = x_malloc(LocalMemSize);
    ASSERT(m_LocalData);
    x_memset(m_LocalData,0x0,LocalMemSize);
    s_ChanBuffer.Longs[0]=(u32)m_LocalData;
    s_ChanBuffer.Longs[1]=LocalMemSize;
    TotalMemSize = CallRpc(CHANCMD_RESIZE,sizeof(s32)*2,sizeof(s32)*2);
    s_RpcLock.Release();
    ASSERT(TotalMemSize > 0);
    return TotalMemSize;
}

volatile s32 g_ActiveHardwareChannels = 0;

//-----------------------------------------------------------------------------
void iop_channel_manager::Update(void)
{
    s32                 i;
    iop_channel*        pData;
    iop_channel_state*  pChanState;
    xbool               bCanStart;
    xbool               bQueueStart = FALSE;
    xbool               ImmediateRetry;

again:
    ASSERT( s_Initialized );
    ImmediateRetry = FALSE;
    g_ActiveHardwareChannels = 0;
    // Ok to do the hardwre update?
    bCanStart = g_AudioHardware.GetDoHardwareUpdate();
    ASSERT(g_AudioHardware.CanModifyChannelList());

    // Clear it.
    g_AudioHardware.ClearDoHardwareUpdate();

    xtimer t;

    t.Start();

    xbool IsLocked = TRUE;

    while( TRUE )
    {
        iop_push_request* pRequest;

        pRequest = (iop_push_request*)m_qPushPending.Recv(MQ_NOBLOCK);
        if( pRequest == NULL )
            break;

        if( IsLocked )
        {
            g_AudioHardware.Unlock();
            IsLocked = FALSE;
        }

        s_RpcLock.Acquire();

        x_memcpy(&s_ChanBuffer,pRequest,sizeof(iop_push_request));
#if defined(DEBUG_AUDIO)
        x_DebugMsg("iop_channel_manager::Update, push request: src:0x%08x, dst:0x%08x, length:0x%06x\n",pRequest->pSource, pRequest->pDest, pRequest->Length );
#endif
        CallRpc(CHANCMD_PUSHDATA, sizeof(iop_push_request), sizeof(s32) );
        s_RpcLock.Release();

        if( pRequest->pReplyQ )
        {
            pRequest->pReplyQ->Send(pRequest->pSource,MQ_NOBLOCK);
        }
        m_qPushAvail.Send(pRequest,MQ_BLOCK);
        if( t.ReadMs() > 10.0f )
        {
            ImmediateRetry = TRUE;
            break;
        }
    }

    if( !IsLocked )
    {
        g_AudioHardware.Lock();
    }

    channel*    pChannel;
    channel*    pHead;
    s32         Dirty;
    // Copy internal channel information to the update buffer then send the
    // update buffer to the iop.
    //
    x_WatchdogReset();
    g_AudioHardware.Tick();
    pHead    = g_AudioChannelMgr.UsedList();
    pChannel = pHead->Link.pPrev;

#if defined(rbrannon)
    extern channel* g_DebugChannel;
    if( g_DebugChannel )
        BREAK;
#endif

    while( pChannel != pHead )
    {
        channel* pPrevChannel = pChannel->Link.pPrev;
        // Check if anything needs updating for the voice.
        if( pChannel->Hardware.ChannelId != INVALID_CHANNEL )
        {
            g_ActiveHardwareChannels++;

            Dirty = pChannel->Dirty;
            // Volume Dirty?
            if( Dirty & (CHANNEL_DB_VOLUME | CHANNEL_DB_PAN) )
            {
                if( pChannel->pElement && 
                    pChannel->pElement->pVoice && 
                    pChannel->pElement->pVoice->IsPositional &&
                    pChannel->pElement->pVoice->DegreesToSound != -1 )
                {
                    s32 j = pChannel->pElement->pVoice->DegreesToSound;
                    f32 vLeft  = g_ProLogicIICoeff[j][0] * pChannel->Volume;
                    f32 vRight = g_ProLogicIICoeff[j][1] * pChannel->Volume;
                    s_ChannelManager.SetVolume(pChannel->Hardware.ChannelId, vLeft, vRight );
                }
                else
                {
                    s_ChannelManager.SetVolume(pChannel->Hardware.ChannelId,pChannel->Pan3d.GetX() * pChannel->Volume,pChannel->Pan3d.GetY() * pChannel->Volume);
                }
                Dirty &= ~(CHANNEL_DB_VOLUME | CHANNEL_DB_PAN);
            }

            // Pitch Dirty?
            if( Dirty & CHANNEL_DB_PITCH )
            {
                s_ChannelManager.SetPitch(pChannel->Hardware.ChannelId,pChannel->Pitch);
                // Clear dirty bit.
                Dirty &= ~CHANNEL_DB_PITCH;
            }

            if( Dirty & CHANNEL_DB_EFFECTSEND )
            {
                // TODO: Put Effect send in.

                s_ChannelManager.SetReverb( pChannel->Hardware.ChannelId, pChannel->EffectSend );
                //s_ChannelManager.SetReverb( pChannel->Hardware.ChannelId, 0.0f );

                // Clear dirty bit.
                Dirty &= ~CHANNEL_DB_EFFECTSEND;
            }

            // Update the dirty flags.
            pChannel->Dirty = Dirty;

            // Enforce the pitch lock
            if( pChannel->pElement && pChannel->pElement->pVoice && pChannel->pElement->pVoice->bPitchLock )
            {
                s_ChannelManager.SetPitchLock(pChannel->Hardware.ChannelId, TRUE );
            }
            else
            {
                s_ChannelManager.SetPitchLock(pChannel->Hardware.ChannelId, FALSE );
            }

            // Update state machine.
            switch( pChannel->State )
            {
                case STATE_NOT_STARTED:
                    break;
                case STATE_STARTING:
                {
                    xbool bStart = bCanStart;

                    if( pChannel->pElement && pChannel->pElement->pVoice && (pChannel->pElement->pVoice->StartQ==2) )
                    {
                        bStart      = TRUE;
                        bQueueStart = TRUE;
                    }

                    if( bStart )
                    {
                        g_AudioHardware.StartChannel( pChannel );
                        pChannel->State = STATE_RUNNING;
                    }
                    break;
                }
                case STATE_RESUMING:
                    if( bCanStart )
                    {
                        g_AudioHardware.ResumeChannel( pChannel );
                        pChannel->State = STATE_RUNNING;
                    }
                    break;
                case STATE_RUNNING:
                    // Update its current position.
                    pChannel->CurrBufferPosition              = (u32)GetPlayPosition(pChannel->Hardware.ChannelId);
                    pChannel->Hardware.RelativeBufferPosition = (u32)GetRelativePlayPosition(pChannel->Hardware.ChannelId);

                    // If voice stopped playing sound then release hardware channel.
                    if( !UpdatePosition(pChannel) || m_Channels[pChannel->Hardware.ChannelId].m_Status == CHANSTAT_IDLE)
                    {
    //                    if( pChannel->pElement->Type == COLD_SAMPLE )
    //                        LOG_MESSAGE( "Start/Stop", "STOP1: %s", pChannel->pElement->pVoice->pDescriptor );

                        g_AudioHardware.ReleaseChannel(pChannel);
                        pChannel->State = STATE_STOPPED;
                    }
                    break;
                case STATE_PAUSING:
                    if( bCanStart )
                    {
                        g_AudioHardware.PauseChannel( pChannel );
                        pChannel->State = STATE_PAUSED;
                    }
                    break;
                
                case STATE_PAUSED:
                case STATE_STOPPED:
                    // Don't do a damned thing...
                    break;
            }
        }

        pChannel = pPrevChannel;
    }

    s_RpcLock.Acquire();
    s_ChanBuffer.Update.MasterVolume = (s32)(m_MasterVolume * 16383.0f);
    s_ChanBuffer.Update.PCMVolume    = (s32)(m_PCMVolume * 16383.0f);
    s_ChanBuffer.Update.ReverbType   = m_ReverbType;
    s_ChanBuffer.Update.ReverbVolume = (s32)0;//(m_ReverbVolume * 16383.0f);
    pData = s_ChanBuffer.Update.Channels;
    pChanState = m_Channels;
#if !defined(X_RETAIL)
    s32 ChannelsInUse;
    s32 ChannelsStealing;

    ChannelsInUse = 0;
    ChannelsStealing = 0;
#endif

    f32 PitchFactor  = g_AudioHardware.GetPitchFactor();
    f32 VolumeFactor  = g_AudioHardware.GetVolumeFactor();
    s32 SpeakerConfig = g_AudioMgr.GetSpeakerConfig();
    for( i=0; i<MAX_CHANNELS; i++ )
    {
        //
        // This HACK is to prevent orphaned channels.  If the channel ID of the owner is INVALID,
        // then there is no way to link an audio_mgr channel to the hardware channel.
        // Setting the status to cooling is the normal way to start stopping a channel.
        //
        // We don't know why this orphaning occurs, but we have to ship in a week, SO....
        // Hackity....hack...hack....hack....
        //
        if( (pChanState->m_Status == CHANSTAT_PLAYING) )
        {
            if( pChanState->m_pOwner && (((channel*)pChanState->m_pOwner)->Hardware.ChannelId != i) )
            {
                s_ChannelManager.SetState( i, CHANSTAT_COOLING );
            }
        }

#if !defined(X_RETAIL)
        if( pChanState->m_Status != CHANSTAT_IDLE )
        {
            ChannelsInUse++;
        }

        if( pChanState->m_Status == CHANSTAT_STEALING )
        {
            ChannelsStealing++;
        }
#endif

#if defined(DEBUG_AUDIO)
        if( pChanState->m_Status != pData->m_Status )
        {
            LOG_MESSAGE(xfs("iop_channel_manager::Update[%d]",i) ,"EE  State changed from:%s to:%s",GetStatusName(pData->m_Status), GetStatusName(pChanState->m_Status));
        }
#endif

        pData->m_Flags          = 0;
        if( pChanState->m_bPitchLock )
        {
            pData->m_Pitch      = 4096;
        }
        else
        {
            pData->m_Pitch      = (s32)(pChanState->m_Pitch * PitchFactor * 4096.0f);
        }
        pData->m_LeftVolume     = (s32)(x_min(pChanState->m_LeftVolume * VolumeFactor, 1.0f) * 16383.0f);
        pData->m_RightVolume    = (s32)(x_min(pChanState->m_RightVolume * VolumeFactor, 1.0f) * 16383.0f);
        switch( SpeakerConfig )
        {
            case SPEAKERS_MONO:
                pData->m_RightVolume = pData->m_LeftVolume;
                break;
            case SPEAKERS_STEREO:
                pData->m_LeftVolume  = x_abs( pData->m_LeftVolume );
                pData->m_RightVolume = x_abs( pData->m_RightVolume );
                break;
        }
        pData->m_Priority       = pChanState->m_Priority;
        pData->m_Status         = pChanState->m_Status;
        pData->m_Reverb         = 0;//(s32)(pChanState->m_Reverb * 100.0f);

        pData->m_Base           = pChanState->m_pSample;
        pData->m_LoopStart      = pChanState->m_pLoopStart;
        pData->m_LoopEnd        = pChanState->m_pLoopEnd;
        pData->m_Length         = pChanState->m_Length;
        pData->m_SampleRate     = pChanState->m_Rate;
        if( pChanState->m_StateDirty )
        {
            pData->m_Flags |= CHANFLAG_DIRTY;
        }
        pChanState->m_StateDirty= FALSE;
        pData++;
        pChanState++;
    }
#if !defined(X_RETAIL)
    m_ActiveChannels = ChannelsInUse;
    m_ChannelsStealing = ChannelsStealing;
#endif
    ///***BIG NOTE*** the periodic update thread that calls this thread is responsible for
    // locking the audio hardware so all we do here is unlock it during the actual synchronous
    // update to the IOP. It is VERY important that this is re-acquired before exiting this
    // routine.
    g_AudioHardware.Unlock();

    CallRpc( CHANCMD_UPDATE, sizeof(s_ChanBuffer), sizeof(s_ChanBuffer) );

    g_AudioHardware.Lock();
    //
    // We copy the status information back to the channel structure once the update has completed.
    // We can also use this time to determine when to initiate a secondary read for streamed samples.
    //
    // pData is the status coming FROM the IOP
    // pChanState is what we wanted to send to the IOP
    pData = s_ChanBuffer.Update.Channels;
    pChanState = m_Channels;
    for( i=0; i<MAX_CHANNELS; i++ )
    {

#if defined(DEBUG_AUDIO)
        if( pChanState->m_Status != pData->m_Status )
        {
            LOG_MESSAGE(xfs("iop_channel_manager::Update[%d]",i) ,"IOP  State changed from:%s to:%s",GetStatusName(pChanState->m_Status), GetStatusName(pData->m_Status));
        }
#endif

        if( !pChanState->m_StateDirty )
        {
            pChanState->m_Status    = (iop_channel_status)pData->m_Status;
        }

        pChanState->m_PlayPosition          = pData->m_Current;
        pChanState->m_RelativePlayPosition  = (byte*)((s32)pData->m_Current - (s32)pData->m_Base);
        pData++;
        pChanState++;
    }

    if( s_ChanBuffer.Update.Stats.SampleLowest < m_Stats.SampleLowest )
    {
        m_Stats.SampleLowest = s_ChanBuffer.Update.Stats.SampleLowest;
    }

    if( s_ChanBuffer.Update.Stats.SampleHighest > m_Stats.SampleHighest )
    {
        m_Stats.SampleHighest = s_ChanBuffer.Update.Stats.SampleHighest;
    }
    
    s_RpcLock.Release();

    // Special stuff when we start a queued sound.
    if( bQueueStart )
    {
        // Loop through active channels (starting with lowest priority).
        pHead    = g_AudioChannelMgr.UsedList();
        pChannel = pHead->Link.pPrev;

        while( pChannel != pHead )
        {    
            if( pChannel->pElement && pChannel->pElement->pVoice && (pChannel->pElement->pVoice->StartQ==2) )
                pChannel->pElement->pVoice->StartQ = 0;
            
            // Previous channel...
            pChannel = pChannel->Link.pPrev;
        }
    }
    if( ImmediateRetry )
        goto again;
}


//-----------------------------------------------------------------------------
s32 iop_channel_manager::PushAvail(void)
{
    return m_qPushAvail.ValidEntries();
}

//-----------------------------------------------------------------------------
void iop_channel_manager::PushData(void* SrcAddr, void* DstAddr, s32 Length,xmesgq* pReplyQ)
{
    iop_push_request* pRequest;

    ASSERT( s_Initialized );
    pRequest = (iop_push_request*)m_qPushAvail.Recv(MQ_BLOCK);
    ASSERT(pRequest);

    pRequest->pSource = SrcAddr;
    pRequest->pDest   = DstAddr;
    pRequest->Length  = Length;
    pRequest->pReplyQ = pReplyQ;
    m_qPushPending.Send(pRequest,MQ_BLOCK);
}

//-----------------------------------------------------------------------------
void iop_channel_manager::PushPCMData( void* pSource, s32 Length, s32 Frequency )
{
    // We need to do this specially since we're about to blast the chanbuffer full
    // of data.
    s_RpcLock.Acquire();
    s_ChanBuffer.Longs[0] = Length;
    s_ChanBuffer.Longs[1] = Frequency;
    ASSERT( Length < ((s32)sizeof(s_ChanBuffer) - (s32)sizeof(s32)*2) );
    x_memcpy( &s_ChanBuffer.Longs[2], pSource, Length );
    CallRpc( CHANCMD_PUSH_PCM, Length + sizeof(s32)*2, 0 );
    s_RpcLock.Release();
}

//-----------------------------------------------------------------------------
void iop_channel_manager::GetStats( s32& Lowest, s32& Highest )
{
    Lowest = m_Stats.SampleLowest;
    Highest = m_Stats.SampleHighest;
    m_Stats.SampleHighest = 0;
    m_Stats.SampleLowest = 0;
}

//-----------------------------------------------------------------------------
void iop_channel_manager::EnableStats( xbool IsEnabled )
{
    s_ChanBuffer.Longs[0]=(u32)IsEnabled;
    s_RpcLock.Acquire();
    CallRpc( CHANCMD_ENABLE_STATS, sizeof(s32), sizeof(s32) );
    s_RpcLock.Release();
}

void EnableAudioLevels( xbool IsEnabled )
{
    s_ChannelManager.EnableStats( IsEnabled );
}

s32 GetAudioLevel( void )
{
    s32 Lowest;
    s32 Highest;

    s_ChannelManager.GetStats( Lowest, Highest );

    if( x_abs( Lowest ) > x_abs( Highest ) )
        return x_abs( Lowest );
    else
        return x_abs( Highest );
}

//-----------------------------------------------------------------------------
void iop_channel_manager::SetState( s32 Channel, iop_channel_status Status )
{
    if( (Status == CHANSTAT_STEALING) || (m_Channels[Channel].m_Status == CHANSTAT_STEALING) )
    {
#ifdef rbrannon
        LOG_MESSAGE("iop_channel_manager::SetState","Channel:%d, state changed from %s to %s\n",Channel, GetStatusName(m_Channels[Channel].m_Status), GetStatusName(Status) );
#endif
    }
    m_Channels[Channel].m_Status  = Status;
    m_Channels[Channel].m_StateDirty = TRUE;
}

const char* GetStatusName( s32 Status )
{
    switch( Status )
    {
    case CHANSTAT_IDLE:         return "CHANSTAT_IDLE";
    case CHANSTAT_STOPPED:      return "CHANSTAT_STOPPED";
    case CHANSTAT_PLAYING:      return "CHANSTAT_PLAYING";
    case CHANSTAT_WARMING:      return "CHANSTAT_WARMING";
    case CHANSTAT_COOLING:      return "CHANSTAT_COOLING";
    case CHANSTAT_STEALING:     return "CHANSTAT_STEALING";
    case CHANSTAT_PAUSED:       return "CHANSTAT_PAUSED";
    default:
        ASSERT(FALSE);
    }
    return "Unknown";
}

//-----------------------------------------------------------------------------

void ps2_DumpChannelInfo( void )
{
    s32 i;
    LOG_FLUSH();
    for( i=0; i<MAX_CHANNELS; i++ )
    {
        const channel& C = s_Channels[i];

        if( (C.Hardware.ChannelId == INVALID_CHANNEL) || (!C.pElement) || (!C.pElement->pVoice) || (!C.pElement->pVoice->pDescriptorName) )
        {
            LOG_MESSAGE("CHANNEL","%02d, ---UNUSED---",
                i
                );
        }
        else
        {
            const char* pStateName = "*****";
            switch( s_ChannelManager.GetState( C.Hardware.ChannelId ) )
            {
                case CHANSTAT_IDLE:     pStateName = " idle"; break;
                case CHANSTAT_STOPPED:  pStateName = " stop"; break;
                case CHANSTAT_PLAYING:  pStateName = " play"; break;
                case CHANSTAT_WARMING:  pStateName = " warm"; break;
                case CHANSTAT_COOLING:  pStateName = " cool"; break;
                case CHANSTAT_STEALING: pStateName = "steal"; break;
                case CHANSTAT_PAUSED:   pStateName = "pause"; break;
            }

            LOG_MESSAGE("CHANNEL","%02d, Prio:%03d, HwID:%03d (%s) %4s '%s'",
                i,
                C.Priority,
                C.Hardware.ChannelId,
                pStateName,
                (C.Type==HOT_SAMPLE) ? ("HOT "):("COLD"),
                C.pElement->pVoice->pDescriptorName
                );
        }
    }
    LOG_FLUSH();
}

//-----------------------------------------------------------------------------
